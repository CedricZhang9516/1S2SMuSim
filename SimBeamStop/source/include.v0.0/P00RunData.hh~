//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// P00RunData.hh
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
/// Run data class
///
/// It defines data members to hold the mu+ stopped position (x, y, z) and stopped time (t).
///
/// The data are collected step by step in P00SteppingAction, and
/// the accumulated values are filled in histograms and ntuple
/// event by event in P00EventAction.

#ifndef P00RunData_h
#define P00RunData_h 1

#include "G4Run.hh"
#include "globals.hh"
#include <array>
#include <map>
#include <vector>

const G4int dAerogelID = 0; // id of Aerogel volumn.
// In case there is other detector volumn in the future,
// they will be assign id=1, 2, etc.

struct TreeVars {
  G4int trkID;
  G4int trkID_ma;
  G4int trkStatus;
  
  G4int trkID    = track->GetTrackID(); // =1 for the primary particle.
  G4int trkID_ma = track->GetParentID();
  G4TrackStatus status= track->GetTrackStatus();

  const G4ParticleDefinition* ptclDef= track->GetParticleDefinition();
  G4String ptclName    = ptclDef->GetParticleName();
  G4double properTime  = track->GetProperTime(); // Proper time of the current track
  G4ThreeVector polVct = track->GetPolarization();

  G4double gblTime     = track->GetGlobalTime(); // Time since this event is created.
  G4double locTime     = track->GetLocalTime();  // Time since the current track is created.
  G4double length      = track->GetTrackLength();
  G4double velocity    = track->GetVelocity();
  G4double totE        = track->GetTotalEnergy();
  G4double kinE        = track->GetKineticEnergy();
  G4ThreeVector trkPos = track->GetPosition();
  G4ThreeVector momVct = track->GetMomentum();
  G4ThreeVector momDir = track->GetMomentumDirection();

  const G4VProcess* creProc = track->GetCreatorProcess();
  G4String creProcName("n/a");
  if( creProc ) creProcName = creProc->GetProcessName();
  G4String creModeName      = track->GetCreatorModelName();
  G4int creModeID           = track->GetCreatorModelID();
  G4ThreeVector prodVtx  = track->GetVertexPosition(); // Track production vertex.
  G4ThreeVector momDir_pv= track->GetVertexMomentumDirection();
  G4double kinE_pv       = track->GetVertexKineticEnergy();
  const G4LogicalVolume* lvol_pv= track->GetLogicalVolumeAtVertex();
  const G4Step* aStep= track->GetStep();
  G4int stepNum      = track->GetCurrentStepNumber();
  G4double stepLen   = track->GetStepLength();
  G4VPhysicalVolume* pvol= track->GetVolume();
  G4cout << ", pvol= " << pvol->GetName();

  G4cout << "; next= ";
  G4VPhysicalVolume* pvol_next= 0;
  if( (pvol_next= track->GetNextVolume()) ){
    // Access the next volume
    G4cout << pvol_next->GetName();
  }else{
    G4cout << "n/a";
  }
 
  G4LogicalVolume* lvol= pvol->GetLogicalVolume();
  G4VPhysicalVolume* pvol_dtr= 0;
  for( G4int i=0; i<lvol->GetNoDaughters(); i++ ){
    // Access the daughter volumes
    if( !(pvol_dtr= lvol->GetDaughter(i)) ) continue;
    G4String space(", ");
    if( i == 0 ) space= "; ";
    G4cout << space << "dtr" << i << "= " << pvol_dtr->GetName();
  }
  G4cout << G4endl;
  
};


class P00RunData : public G4Run
{
public:
           P00RunData();
  virtual ~P00RunData();
  void Add(G4int volID, G4double de,
	   G4double px, G4double py, G4double pz, G4double kinEnergy);
  void FillPerEvent();
  void Reset();

  // Volume that Steppingaction should look into
  G4String  GetVolumeName(G4int volID) const;
  // Energy deposite inside the volumn (aerogel sample)
  G4double  GetEdep(G4int volID) const;        
  // x coordinate of mu+ stopped point inside aerogel
  G4double  GetXPosition(G4int volID) const;   
  // y coordinate of mu+ stopped point inside aerogel
  G4double  GetYPosition(G4int volID) const;   
  // z coordinate of mu+ stopped point inside aerogel
  G4double  GetZPosition(G4int volID) const;   
  G4double  GetKinEnergy(G4int volID) const;

private:

  // Define a 1-dimension "G4String"-type array named "fVolumeName",
  // ARRAY store Name for different volumn.
  // eg. fVolumeNames[volID =dAerogelID =0] ="anyNameUlike"
  std::array<G4String,1> fVolumeNames;
  std::array<G4double,1> fEdep; 
  std::array<G4double,1> fXPosition;
  std::array<G4double,1> fYPosition; 
  std::array<G4double,1> fZPosition;
  std::array<G4double,1> fKinEnergy;



};

// inline functions that will be used in SteppingAction.cc
// REALLY NEEDED INLINE??????
inline void
P00RunData::Add (G4int volID, G4double de,
		 G4double px, G4double py, G4double pz, G4double kinEnergy)
{  
  fEdep[volID] = de;
  fXPosition[volID] = px;
  fYPosition[volID] = py;
  fZPosition[volID] = pz;
  fKinEnergy[volID] = kinEnergy;
}

inline G4String  P00RunData::GetVolumeName(G4int volID) const {
  return fVolumeNames[volID];
}
inline G4double  P00RunData::GetEdep(G4int volID) const {
  return fEdep[volID];
}
inline G4double  P00RunData::GetXPosition(G4int volID) const {
  return fXPosition[volID];
}   
inline G4double  P00RunData::GetYPosition(G4int volID) const {
  return fYPosition[volID];
}
inline G4double  P00RunData::GetZPosition(G4int volID) const{
  return fZPosition[volID];
}
inline G4double  P00RunData::GetKinEnergy(G4int volID) const{
  return fKinEnergy[volID];
}

#endif


