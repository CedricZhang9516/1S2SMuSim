//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// P00RunData.hh
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
/// Run data class
///
/// It defines data members to hold the mu+ stopped position (x, y, z) and stopped time (t).
///
/// The data are collected step by step in P00SteppingAction, and
/// the accumulated values are filled in histograms and ntuple
/// event by event in P00EventAction.

#ifndef P00RunData_h
#define P00RunData_h 1

#include "G4Run.hh"
#include "P00Analysis.hh"
#include "globals.hh"
#include <array>
#include <map>
#include <vector>

#include "G4ThreeVector.hh"
class G4Step;
//class G4Track;

struct TreeVars {
  G4int tgtLevel;
  
  G4int trkStat;
  G4int trkStpNum;
  G4double trkLen;

  G4double stpLen;
  G4double stpDelT;
  G4double stpDelTotE;
  G4double stpDelNiE;
  G4ThreeVector stpDelVtx;

  //-- Variables available from the pre/post-step-point.
  //   index= 0:pre, 1:post
  G4int pntStpStat[2];
  G4int pntPrcType[2];
  G4int pntPrcId[2];
  G4int pntVolId[2];
  G4double pntBeta[2];
  G4double pntGamma[2];

  //-- Variables available from the pre/post-step-point or track.
  //   index= 0:pre, 1:post, 2:track
  G4double pntPrpT[3];
  G4double pntLocT[3];
  G4double pntVelo[3];
  G4double pntKinE[3];
  G4ThreeVector pntVtx[3];
  G4ThreeVector pntMom[3];
};
  //-- track/include/G4TrackStatus.hh
  //  enum G4TrackStatus
  //  {
  //     fAlive,                   // =0: Continue the tracking
  //     fStopButAlive,            // =1: Invoke active rest physics processes and kill the current track afterward
  //     fStopAndKill,             // =2: Kill the current track
  //     fKillTrackAndSecondaries, // =3: Kill the current track and associated secondaries.
  //     fSuspend,                 // =4: Suspend the current track
  //     fPostponeToNextEvent      // =5: Postpones the tracking of the current track to the next event.
  //   };

  //-- track/include/G4StepStatus.hh
  //   enum G4StepStatus
  //   {
  //     fWorldBoundary,     // =0: Step reached the world boundary
  //     fGeomBoundary,      // =1: Step defined by a geometry boundary
  //     fAtRestDoItProc,    // =2: Step defined by a PreStepDoItVector
  //     fAlongStepDoItProc, // =3: Step defined by a AlongStepDoItVector
  //     fPostStepDoItProc,  // =4: Step defined by a PostStepDoItVector
  //     fUserDefinedLimit,  // =5: Step defined by the user Step limit in the logical volume
  //     fExclusivelyForcedProc, //=6: Step defined by an exclusively forced PostStepDoIt process
  //     fUndefined          //=7: Step not defined yet
  //   };

  //-- processes/management/include/G4ProcessType.hh
  //  enum G4ProcessType
  //  { 
  //    fNotDefined,
  //    fTransportation,
  //    fElectromagnetic,
  //    fOptical, 
  //    fHadronic,
  //    fPhotolepton_hadron,
  //    fDecay,
  //    fGeneral,
  //    fParameterisation,
  //    fUserDefined,
  //    fParallel,
  //    fPhonon,
  //    fUCN
  //  };

class P00RunData : public G4Run
{
public:
           P00RunData();
  virtual ~P00RunData();
  void Add(G4int volID, G4double de,
	   G4double px, G4double py, G4double pz, G4double kinEnergy);
  void FillPerEvent();
  void Reset();


  G4int GetProcID( const G4String& procName );

  void SetAllVars( const G4Step* aStep, TreeVars& tv, const G4int& iSetLevel,
		   const G4int& index );
  void SetTrkVars( const G4Step* aStep, TreeVars& tv, const G4int& iSetLevel );
  void SetStpVars( const G4Step* aStep, TreeVars& tv );
  void SetPntVars( const G4Step* aStep, TreeVars& tv, const G4int& index );
  void ClearVars( TreeVars& tv );

  void CreateColumns( G4AnalysisManager* mgr, const G4String& prefix );
  void FillColumns( G4AnalysisManager* mgr, const G4int& tid,
		    G4int& cid, const TreeVars& tv, const G4int& index );

  void CreateTreeGen( const G4String& name, const G4String& title );
  void CreateTreeTgt( const G4String& name, const G4String& title );
  void FillTreeGen( G4AnalysisManager* mgr, const G4int& tid );
  void FillTreeTgt( G4AnalysisManager* mgr, const G4int& tid );
  
  // Volume that Steppingaction should look into
  G4String  GetVolumeName(G4int volID) const;
  // Energy deposite inside the volumn (aerogel sample)
  G4double  GetEdep(G4int volID) const;        
  // x coordinate of mu+ stopped point inside aerogel
  G4double  GetXPosition(G4int volID) const;   
  // y coordinate of mu+ stopped point inside aerogel
  G4double  GetYPosition(G4int volID) const;   
  // z coordinate of mu+ stopped point inside aerogel
  G4double  GetZPosition(G4int volID) const;   
  G4double  GetKinEnergy(G4int volID) const;
  
  G4int hitTgt0;
  G4int hitTgt1;
  G4int extTgt0;
  G4int extTgt1;

  TreeVars tvGenPrd;
  TreeVars tvGenEnd;
  TreeVars tvTgtHit0;
  TreeVars tvTgtHit1;
  TreeVars tvTgtExt0;
  TreeVars tvTgtExt1;

private:

  // Define a 1-dimension "G4String"-type array named "fVolumeName",
  // ARRAY store Name for different volumn.
  // eg. fVolumeNames[volID =dTargetID =0] ="anyNameUlike"
  std::array<G4String,1> fVolumeNames;
  std::array<G4double,1> fEdep; 
  std::array<G4double,1> fXPosition;
  std::array<G4double,1> fYPosition; 
  std::array<G4double,1> fZPosition;
  std::array<G4double,1> fKinEnergy;

};

const G4int dTargetID = 0; // id of Target volumn.
// In case there is other detector volumn in the future,
// they will be assign id=1, 2, etc.

// inline functions that will be used in SteppingAction.cc
// REALLY NEEDED INLINE??????
inline void
P00RunData::Add (G4int volID, G4double de,
		 G4double px, G4double py, G4double pz, G4double kinEnergy)
{  
  fEdep[volID] = de;
  fXPosition[volID] = px;
  fYPosition[volID] = py;
  fZPosition[volID] = pz;
  fKinEnergy[volID] = kinEnergy;
}

inline G4String  P00RunData::GetVolumeName(G4int volID) const {
  return fVolumeNames[volID];
}
inline G4double  P00RunData::GetEdep(G4int volID) const {
  return fEdep[volID];
}
inline G4double  P00RunData::GetXPosition(G4int volID) const {
  return fXPosition[volID];
}   
inline G4double  P00RunData::GetYPosition(G4int volID) const {
  return fYPosition[volID];
}
inline G4double  P00RunData::GetZPosition(G4int volID) const{
  return fZPosition[volID];
}
inline G4double  P00RunData::GetKinEnergy(G4int volID) const{
  return fKinEnergy[volID];
}

#endif


